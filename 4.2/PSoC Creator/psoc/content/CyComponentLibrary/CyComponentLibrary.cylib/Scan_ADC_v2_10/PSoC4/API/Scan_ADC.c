/***************************************************************************//**
* \file     `$INSTANCE_NAME`.c
* \version  `$CY_MAJOR_VERSION`.`$CY_MINOR_VERSION`
*
* \brief
* Provides the source code to the API for the `$INSTANCE_NAME` Component.
*
********************************************************************************
* \copyright
* (c) 2015-2016, Cypress Semiconductor Corporation. All rights reserved.
* This software, including source code, documentation and related
* materials ("Software"), is owned by Cypress Semiconductor
* Corporation ("Cypress") and is protected by and subject to worldwide
* patent protection (United States and foreign), United States copyright
* laws and international treaty provisions. Therefore, you may use this
* Software only as provided in the license agreement accompanying the
* software package from which you obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, nonexclusive,
* non-transferable license to copy, modify, and compile the
* Software source code solely for use in connection with Cypress's
* integrated circuit products. Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO
* WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING,
* BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
* PARTICULAR PURPOSE. Cypress reserves the right to make
* changes to the Software without notice. Cypress does not assume any
* liability arising out of the application or use of the Software or any
* product or circuit described in the Software. Cypress does not
* authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/
#include "`$INSTANCE_NAME`.h"

static int32 `$INSTANCE_NAME`_IsChannelSigned(uint32 chan);
#if(`$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER	!= 0u)
static void `$INSTANCE_NAME`_SetupComparatorTrim(void);
static void `$INSTANCE_NAME`_UndoComparatorTrimSetup(void);
static uint32 `$INSTANCE_NAME`_RaiseOpampTrimToCrossing(uint32 startTrim);
static uint32 `$INSTANCE_NAME`_LowerOpampTrimToCrossing(uint32 startTrim);
static uint32 `$INSTANCE_NAME`_RaiseAgndTrimToCrossing(uint32 startTrim);
static uint32 `$INSTANCE_NAME`_LowerAgndTrimToCrossing(uint32 startTrim);
static uint32 `$INSTANCE_NAME`_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim);
static uint32 `$INSTANCE_NAME`_SetOpampTrim(uint32 opampTrim);
static uint32 `$INSTANCE_NAME`_SetAgndTrim(uint32 agndTrim);
static uint32 `$INSTANCE_NAME`_IncOpampTrim(uint32 trim);
static uint32 `$INSTANCE_NAME`_DecOpampTrim(uint32 trim);
static uint32 `$INSTANCE_NAME`_IncAgndTrim(uint32 trim);
static uint32 `$INSTANCE_NAME`_DecAgndTrim(uint32 trim);
#define OFFSET_SAMPLES (30)
#endif

uint8 `$INSTANCE_NAME`_initVar = 0u; 

uint8 `$INSTANCE_NAME`_selected = 0u; /* 0 if no configuration selected. 1 otherwise. */
volatile int16 `$INSTANCE_NAME`_offset[`$INSTANCE_NAME`_TOTAL_CHANNELS_NUM]; 
volatile int32 `$INSTANCE_NAME`_countsPer10Volt[`$INSTANCE_NAME`_TOTAL_CHANNELS_NUM]; 

static uint32 `$INSTANCE_NAME`_currentConfig = 0u; /* Currently active configuration */

/*******************************************************************************
* Local data allocation
*******************************************************************************/
/* Channels configuration generated by customiser */
`$channelsConfig`

/* Filter init */
#if(`$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER	!= 0u)
    #if (0u != `$INSTANCE_NAME`_CFG0_FILTER_PRESENT)
        #define `$INSTANCE_NAME`_CFG0_UABH_A_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG0_UABH_A_FILTER_initPairs[`$INSTANCE_NAME`_CFG0_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_A_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_A_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_A_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        #define `$INSTANCE_NAME`_CFG0_UABH_B_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG0_UABH_B_FILTER_initPairs[`$INSTANCE_NAME`_CFG0_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_B_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_B_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_B_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG0_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (`$INSTANCE_NAME`_CFG0_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG0_UABH_A_FILTER_config = {
            `$INSTANCE_NAME`_UABH_A_waveConfig,
            (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG0_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_A_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_A_PARAM_AGND_TIED,
                `$INSTANCE_NAME`_UABH_A_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_A_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_A_PARAM_SW_AA),
            `$INSTANCE_NAME`_UABH_A_NUM_STEPS,
            (uint8)(`$INSTANCE_NAME`_UABH_A_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG0_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG0_UABH_B_FILTER_config = {
        `$INSTANCE_NAME`_UABH_B_waveConfig,
        (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG0_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_B_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_B_PARAM_AGND_TIED,
            `$INSTANCE_NAME`_UABH_B_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_B_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_B_PARAM_SW_AA),
        `$INSTANCE_NAME`_UABH_B_NUM_STEPS,
        (uint8)(`$INSTANCE_NAME`_UABH_B_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG0_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != `$INSTANCE_NAME`_CFG0_FILTER_PRESENT) */
    #if (0u != `$INSTANCE_NAME`_CFG1_FILTER_PRESENT)
        #define `$INSTANCE_NAME`_CFG1_UABH_A_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG1_UABH_A_FILTER_initPairs[`$INSTANCE_NAME`_CFG1_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_A_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_A_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_A_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        #define `$INSTANCE_NAME`_CFG1_UABH_B_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG1_UABH_B_FILTER_initPairs[`$INSTANCE_NAME`_CFG1_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_B_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_B_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_B_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG1_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (`$INSTANCE_NAME`_CFG1_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG1_UABH_A_FILTER_config = {
            `$INSTANCE_NAME`_UABH_A_waveConfig,
            (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG1_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_A_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_A_PARAM_AGND_TIED,
                `$INSTANCE_NAME`_UABH_A_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_A_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_A_PARAM_SW_AA),
            `$INSTANCE_NAME`_UABH_A_NUM_STEPS,
            (uint8)(`$INSTANCE_NAME`_UABH_A_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG1_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG1_UABH_B_FILTER_config = {
        `$INSTANCE_NAME`_UABH_B_waveConfig,
        (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG1_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_B_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_B_PARAM_AGND_TIED,
            `$INSTANCE_NAME`_UABH_B_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_B_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_B_PARAM_SW_AA),
        `$INSTANCE_NAME`_UABH_B_NUM_STEPS,
        (uint8)(`$INSTANCE_NAME`_UABH_B_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG1_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != `$INSTANCE_NAME`_CFG1_FILTER_PRESENT) */
    #if (0u != `$INSTANCE_NAME`_CFG2_FILTER_PRESENT)
        #define `$INSTANCE_NAME`_CFG2_UABH_A_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG2_UABH_A_FILTER_initPairs[`$INSTANCE_NAME`_CFG2_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_A_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_A_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_A_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        #define `$INSTANCE_NAME`_CFG2_UABH_B_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG2_UABH_B_FILTER_initPairs[`$INSTANCE_NAME`_CFG2_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_B_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_B_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_B_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG2_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (`$INSTANCE_NAME`_CFG2_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG2_UABH_A_FILTER_config = {
            `$INSTANCE_NAME`_UABH_A_waveConfig,
            (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG2_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_A_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_A_PARAM_AGND_TIED,
                `$INSTANCE_NAME`_UABH_A_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_A_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_A_PARAM_SW_AA),
            `$INSTANCE_NAME`_UABH_A_NUM_STEPS,
            (uint8)(`$INSTANCE_NAME`_UABH_A_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG2_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG2_UABH_B_FILTER_config = {
        `$INSTANCE_NAME`_UABH_B_waveConfig,
        (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG2_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_B_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_B_PARAM_AGND_TIED,
            `$INSTANCE_NAME`_UABH_B_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_B_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_B_PARAM_SW_AA),
        `$INSTANCE_NAME`_UABH_B_NUM_STEPS,
        (uint8)(`$INSTANCE_NAME`_UABH_B_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG2_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != `$INSTANCE_NAME`_CFG2_FILTER_PRESENT) */
    #if (0u != `$INSTANCE_NAME`_CFG3_FILTER_PRESENT)
        #define `$INSTANCE_NAME`_CFG3_UABH_A_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 18u \
                                                             : 18u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG3_UABH_A_FILTER_initPairs[`$INSTANCE_NAME`_CFG3_UABH_A_FILTER_INITPAIRSSIZE] =
        {
        	/*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_A_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_MODBIT_SRC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_A_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_A_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_A_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_A_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_LOWQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
                /* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_A_HIGHQSTAT_SW_CF_BOT)}

                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_A_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_A_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_A_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        #define `$INSTANCE_NAME`_CFG3_UABH_B_FILTER_INITPAIRSSIZE ((`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) \
                                                             ? 19u \
                                                             : 19u)
        const static CyUAB_reg_pair `$INSTANCE_NAME`_CFG3_UABH_B_FILTER_initPairs[`$INSTANCE_NAME`_CFG3_UABH_B_FILTER_INITPAIRSSIZE] = 
        {
            /*OA_CTRL default always first element in initPairs*/
            /* Topology-invariant registers */
             {`$INSTANCE_NAME`_UABH_B_OA_CTRL_PTR        , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_OA_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_STATIC_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_STATIC)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_MODBIT_SRC_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SW_MODBIT_SRC)}
            ,{`$INSTANCE_NAME`_UABH_B_SRAM_CTRL_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_INVAR_SRAM_CTRL)} 
            ,{`$INSTANCE_NAME`_UABH_B_STARTUP_DELAY_PTR  , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_STARTUP_DELAY)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_BOOST_CTRL_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_BOOST_CTRL)}
            ,{`$INSTANCE_NAME`_UABH_B_SW_OTHER_PTR  , ((uint32)`$INSTANCE_NAME`_UABH_B_DEFAULT_SW_OTHER)}
            
            #if (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q)
                    	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_LOWQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_LOWQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_LOWQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_LOWQDYN_CAP_ABCF_VAL)}
            #elif (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_HIGH_Q)
            	/* Filter-invariant registers */
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CA_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CA_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CB_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN0_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN0)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_IN1_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CC_IN1)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CF_BOT_PTR      , ((uint32)`$INSTANCE_NAME`_UABH_B_HIGHQSTAT_SW_CF_BOT)}
                
                /* Parameter-based registers */
                ,{`$INSTANCE_NAME`_UABH_B_CAP_CTRL_PTR       , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_HIGHQDYN_CAP_CTRL)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CB_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_HIGHQDYN_SW_CB_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_SW_CC_TOP_PTR      , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_HIGHQDYN_SW_CC_TOP)}
                ,{`$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_PTR   , ((uint32)`$INSTANCE_NAME`_CFG3_UABH_B_HIGHQDYN_CAP_ABCF_VAL)}
            #endif /* #if (`$INSTANCE_NAME`_CFG3_FILTERTYPE_USED == `$INSTANCE_NAME`_FILTERTOPOLOGY_LOW_Q) */
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG3_UABH_A_FILTER_config = {
            `$INSTANCE_NAME`_UABH_A_waveConfig,
            (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG3_UABH_A_FILTER_initPairs,
            CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_A_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_A_PARAM_AGND_TIED,
                `$INSTANCE_NAME`_UABH_A_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_A_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_A_PARAM_SW_AA),
            `$INSTANCE_NAME`_UABH_A_NUM_STEPS,
            (uint8)(`$INSTANCE_NAME`_UABH_A_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG3_UABH_A_FILTER_initPairs))
        };

        const static CyUAB_config `$INSTANCE_NAME`_CFG3_UABH_B_FILTER_config = {
        `$INSTANCE_NAME`_UABH_B_waveConfig,
        (CyUAB_reg_pair*) `$INSTANCE_NAME`_CFG3_UABH_B_FILTER_initPairs,
        CyUAB_SHARED_SW_CFG(`$INSTANCE_NAME`_UABH_B_PARAM_REF_TIED,`$INSTANCE_NAME`_UABH_B_PARAM_AGND_TIED,
            `$INSTANCE_NAME`_UABH_B_PARAM_SW_CC,`$INSTANCE_NAME`_UABH_B_PARAM_SW_BB,`$INSTANCE_NAME`_UABH_B_PARAM_SW_AA),
        `$INSTANCE_NAME`_UABH_B_NUM_STEPS,
        (uint8)(`$INSTANCE_NAME`_UABH_B_ELEMENT_COUNT(`$INSTANCE_NAME`_CFG3_UABH_B_FILTER_initPairs))
    };
    #endif /* (0u != `$INSTANCE_NAME`_CFG3_FILTER_PRESENT) */
    
    
#endif /* (`$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER	!= 0u)	*/

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_Start
****************************************************************************//**
*
* \brief Performs all required initialization for this component and enables the 
*  power. The power will be set to the appropriate power based on the clock 
*  frequency.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
* \globalvars
*  \ref `$INSTANCE_NAME`_initVar (RW)
*
*******************************************************************************/
void `$INSTANCE_NAME`_Start(void)
{
    if (`$INSTANCE_NAME`_INIT_VAR_INIT_FLAG != (`$INSTANCE_NAME`_INIT_VAR_INIT_FLAG & `$INSTANCE_NAME`_initVar))
    {
        `$INSTANCE_NAME`_Init();
        `$INSTANCE_NAME`_initVar |= `$INSTANCE_NAME`_INIT_VAR_INIT_FLAG;
    }
    
    `$INSTANCE_NAME`_Enable();
    
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_StartEx
****************************************************************************//**
*
* \brief This function starts the `$INSTANCE_NAME` and sets the Interrupt 
* Service Routine to the provided address using the 
* `$INSTANCE_NAME`_IRQ_StartEx() function. Refer to the Interrupt component 
* datasheet for more information on the `$INSTANCE_NAME`_IRQ_StartEx() function.
* 
* \param address This is the address of a user defined function for the ISR.
* 
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_StartEx(cyisraddress address)
{
    `$INSTANCE_NAME`_Start();
    `$INSTANCE_NAME`_IRQ_StartEx(address);
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_Stop
****************************************************************************//**
*
* \brief This function stops ADC conversions and puts the ADC into its lowest 
* power mode.
* 
* \param None
* 
* \return None
* 
* \sideeffect
* Do not use the `$INSTANCE_NAME`_Stop() API to halt conversions. Instead use the 
* `$INSTANCE_NAME`_StopConvert() API. If you use the `$INSTANCE_NAME`_Stop() API 
* to halt conversions then later use the `$INSTANCE_NAME`_Start() and 
* `$INSTANCE_NAME`_StartConvert() APIs to resume conversions, the first channel 
* of the scan may be corrupt. The `$INSTANCE_NAME`_StopConvert() API will enable 
* the `$INSTANCE_NAME` to complete the current scan of channels. After the 
* channel scan is complete, the `$INSTANCE_NAME` will stop all conversions, which 
* can be detected by the use of an ISR or the `$INSTANCE_NAME`_IsEndConversion() 
* flag.
*
*******************************************************************************/
void `$INSTANCE_NAME`_Stop(void)
{	
    #if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)	
    	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].miscConfig 
    	   & `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	   == `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
    		`$INSTANCE_NAME`_UABH_A_Stop();
    		`$INSTANCE_NAME`_UABH_B_Stop();
            `$INSTANCE_NAME`_FILTERAGND2SAR_BUFFER_Stop();
    	}
    #endif /* `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER != 0u */
    `$INSTANCE_NAME`_SAR_CTRL_REG &= (uint32)~`$INSTANCE_NAME`_SAR_CTRL_ENABLED_MSK;
    return;
}

/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_InitConfig
****************************************************************************//*
*
* \brief Configures all of the registers for a given configuration for scanning.
*
* \param scan Number of scan defined in the `$INSTANCE_NAME`.
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_InitConfig(const `$INSTANCE_NAME`_CONFIG_STRUCT *config)
{
	uint32 chNum;
    uint32 tmpRegVal;
	
    /* If there is an internal SAR clock, set up its divider values. */
    #if (`$INSTANCE_NAME`_CLOCK_INTERNAL)
        `$INSTANCE_NAME`_intSarClock_Stop();
        `$INSTANCE_NAME`_intSarClock_SetFractionalDividerRegister(config->clkDivider, 0u);
        `$INSTANCE_NAME`_intSarClock_Start();
    #endif /* `$INSTANCE_NAME`_CLOCK_INTERNAL */
    
    /* If the current configuration has a filter, set up the UAB clock divider values. */
    #if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)	        
    	if((config->miscConfig & `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            `$INSTANCE_NAME`_intUabClock_Stop(); 
            `$INSTANCE_NAME`_intUabClock_SetFractionalDividerRegister(config->filterClkDivider, 0u); 
            #if defined(`$INSTANCE_NAME`_cy_psoc4_sar_1__CLOCK_DIV_ID)
                /* If the SAR clock divider ID is known,
                 * start the internal UAB divider aligned to the SAR divider. */
                `$INSTANCE_NAME`_intUabClock_StartEx(`$INSTANCE_NAME`_cy_psoc4_sar_1__CLOCK_DIV_ID);
            #else
                /* Otherwise start it unaligned. */
                `$INSTANCE_NAME`_intUabClock_Start();
            #endif
    	}
    #endif /* `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER != 0u */
    
    /* Init SAR and MUX registers */
	/* Enable the SAR internal pump when global pump is enabled */
	`$INSTANCE_NAME`_SAR_CTRL_REG = config->ctrl
        | (((`$INSTANCE_NAME`_PUMP_CTRL_REG & `$INSTANCE_NAME`_PUMP_CTRL_ENABLED) != 0u) 
            ? `$INSTANCE_NAME`_SAR_CTRL_BOOSTPUMP_EN_MSK : 0u);
	
	`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG = config->sampleCtrl;
	`$INSTANCE_NAME`_SAR_RANGE_THRES_REG = config->rangeThres;	
	`$INSTANCE_NAME`_SAR_RANGE_COND_REG = config->rangeCond;
	`$INSTANCE_NAME`_SAR_SAMPLE_TIME01_REG = config->sampleTime01;
	`$INSTANCE_NAME`_SAR_SAMPLE_TIME23_REG = config->sampleTime23;
    
	/* Connect Vminus to VSSA when even one channel is single-ended or multiple channels configured */
	if(1u == `$INSTANCE_NAME`_MUX_SWITCH0_INIT)
	{
		`$INSTANCE_NAME`_MUX_SWITCH0_REG |= `$INSTANCE_NAME`_MUX_FW_VSSA_VMINUS;
		/* Set MUX_HW_CTRL_VSSA in MUX_SWITCH_HW_CTRL when multiple channels enabled */
		if(1ul < config->numChannels)
		{
			`$INSTANCE_NAME`_MUX_SWITCH_HW_CTRL_REG |= `$INSTANCE_NAME`_MUX_FW_VSSA_VMINUS;
		}
	}
    
	/* Clear and set interrupt masks */
	`$INSTANCE_NAME`_SAR_SATURATE_INTR_MASK_REG = 0u;
    `$INSTANCE_NAME`_SAR_RANGE_INTR_MASK_REG = 0u;	
	`$INSTANCE_NAME`_SAR_SATURATE_INTR_MASK_REG = config->satIntMask;
	`$INSTANCE_NAME`_SAR_RANGE_INTR_MASK_REG = config->rangeIntMask;
	`$INSTANCE_NAME`_SAR_INTR_MASK_REG = `$INSTANCE_NAME`_EOS_MASK;
    
	/* Double the non-overlap delay and latch enable time when using */
    /* internal reference without bypass cap */
    tmpRegVal = `$INSTANCE_NAME`_SAR_DFT_CTRL_REG;
	if(((config->ctrl & `$INSTANCE_NAME`__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == `$INSTANCE_NAME`__INTERNAL1024) 
	    || ((config->ctrl & `$INSTANCE_NAME`__SAR_CTRL_VREF_BYP_AND_SEL_MSK) 
	    == `$INSTANCE_NAME`__INTERNALVREF))
	{
        tmpRegVal &= ~`$INSTANCE_NAME`_SAR_DFT_CTRL_DCEN_MSK;
		tmpRegVal |= `$INSTANCE_NAME`_SAR_DFT_CTRL_DLY_INC_MSK;
	}
	else
	{
		tmpRegVal |= `$INSTANCE_NAME`_SAR_DFT_CTRL_DCEN_MSK;
        tmpRegVal &= (uint32)~`$INSTANCE_NAME`_SAR_DFT_CTRL_DLY_INC_MSK;
	}	
	`$INSTANCE_NAME`_SAR_DFT_CTRL_REG = tmpRegVal;
	
	for(chNum = 0u; chNum < config->numChannels; chNum++)
    {
		tmpRegVal = (`$INSTANCE_NAME`_channelsConfig[config->channelBase + chNum] 
		& `$INSTANCE_NAME`_CHANNEL_CONFIG_MASK);
        
        #if(`$INSTANCE_NAME`_TOTAL_CHANNELS_NUM > 1)
            tmpRegVal |= `$INSTANCE_NAME`_InputsPlacement[config->channelBase + chNum];
            /*Non-paired differential channels set NEG_ADDR_EN and clear DIFFERENTIAL_EN */
            if(0u != (`$INSTANCE_NAME`_InputsPlacement[config->channelBase + chNum] & `$INSTANCE_NAME`_CHANNEL_CONFIG_NEG_ADDR_EN_MSK))
            {
                tmpRegVal &= ~`$INSTANCE_NAME`_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK;
            }
        #endif
        
		CY_SET_REG32((reg32 *)(`$INSTANCE_NAME`_SAR_CHAN_CONFIG_IND + (uint32)(chNum << 2)), tmpRegVal);
	}
	
    return;
}

/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_SelectConfig
****************************************************************************//* 
*
* \brief Selects the predefined configuration for scanning. Disables
* and re-enables the SAR and filter (if filter used).
* 
* \param config Number of configuration  in the `$INSTANCE_NAME`.
* 
* \param restart Set to 1u to restart the `$INSTANCE_NAME` after 
* selecting the configuration.
*
*******************************************************************************/
void `$INSTANCE_NAME`_SelectConfig(uint32 config, uint32 restart)
{
    /* Check whether the configuration number is valid or not */
    if(`$INSTANCE_NAME`_TOTAL_CONFIGS > config)
    {        
        /* Stop the ADC before changing configurations */
	    `$INSTANCE_NAME`_Stop();
        `$INSTANCE_NAME`_selected = 1u;
        
    	if(0u == `$INSTANCE_NAME`_initVar)
    	{
            `$INSTANCE_NAME`_Init();
            `$INSTANCE_NAME`_initVar |= `$INSTANCE_NAME`_INIT_VAR_INIT_FLAG;
    	}
        #if (`$INSTANCE_NAME`_VREF_ROUTED)
            `$INSTANCE_NAME`_vrefAMux_DisconnectAll();
        #endif
    	`$INSTANCE_NAME`_InitConfig(&`$INSTANCE_NAME`_allConfigs[config]);
        #if (`$INSTANCE_NAME`_VREF_ROUTED)
            `$INSTANCE_NAME`_vrefAMux_Select((uint8)config);
        #endif
        #if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)
            `$INSTANCE_NAME`_filterVinMux_Select((uint8)config);
            `$INSTANCE_NAME`_filterInit(config);
        #endif
    	`$INSTANCE_NAME`_SAR_CHAN_EN_REG = `$INSTANCE_NAME`_allConfigs[config].chanEn;
    	`$INSTANCE_NAME`_SAR_RANGE_INTR_MASK_REG = `$INSTANCE_NAME`_allConfigs[config].rangeIntMask;
    	`$INSTANCE_NAME`_SAR_SATURATE_INTR_MASK_REG = `$INSTANCE_NAME`_allConfigs[config].satIntMask;
    	`$INSTANCE_NAME`_currentConfig = config;
        
        if(1u == restart)
        {
            /* Restart the ADC */    
            `$INSTANCE_NAME`_Start();
            
            /* Restart the scan */
            `$INSTANCE_NAME`_StartConvert();
        }
    }
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_StartConvert
****************************************************************************//**
*
* \brief In continuous mode, this API starts the conversion process and it runs 
* continuously. 

* In Single Shot mode, the function triggers a single scan and 
* every scan requires a call of this function. The mode is set with the 
* Sample Mode parameter in the customizer. The customizer setting can be 
* overridden at run time with the `$INSTANCE_NAME`_SetConvertMode() function.
* 
* \param None
* 
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_StartConvert(void)
{
	/* Freerunning mode */
	if((`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG 
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
    {
		`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG |= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_CONTINUOUS_MSK ;
	}
	else /* Firmware trigger */
	{
		`$INSTANCE_NAME`_SAR_START_CTRL_REG = `$INSTANCE_NAME`_SAR_START_CTRL_FW_TRIGGER_MSK;
	}
    
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_StopConvert
****************************************************************************//**
*
* \brief Forces the `$INSTANCE_NAME` to stop conversions. If a conversion is 
* currently executing, that conversion will complete, but no further conversions 
* will occur.
* 
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_StopConvert(void)
{
    if((`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG  
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK) 
		== `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK)
	{
        `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG &= ~`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_CONTINUOUS_MSK;
        
        if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].miscConfig 
            & `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK) 
    	    == `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK)
        {
            /* Re-synchronize the Filter if a filter is present */
            `$INSTANCE_NAME`_Stop();
            `$INSTANCE_NAME`_Start();
        }
	}
    
    return;
}
/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetConvertMode
****************************************************************************//**
*
* \brief Sets the conversion mode to either Single-Shot or continuous. This 
* function overrides the settings applied in the customizer. Changing 
* configurations will restore the values set in the customizer.
*
* \param mode Sets the conversion mode. See table below for details.
* | Options                          | Description                             |
* | :------------------------------- | :-------------------------------------- |
* | `$INSTANCE_NAME`_SINGLE_SHOT     | Calling the `$INSTANCE_NAME`_StartConvert() function after setting mode this will trigger a single scan. Sets the SOC signal to be edge sensitive, each edge will trigger a single scan. |
* | `$INSTANCE_NAME`_CONTINUOUS      | Calling the `$INSTANCE_NAME`_StartConvert() function after setting this mode trigger continuous scanning. This mode sets the SOC signal to be level sensitive. The `$INSTANCE_NAME` will continuously scan while soc is active. |
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetConvertMode(uint32 mode)
{
    if(`$INSTANCE_NAME`_CONTINUOUS == mode)
    {
        `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG |= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
    else
    {
        `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_REG &= ~`$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DSI_TRIGGER_LEVEL_MSK;       
    }
}
/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_IRQ_Enable
****************************************************************************//*
*
* \brief Enables interrupts to occur at the end of a conversion. Global 
* interrupts must also be enabled for the `$INSTANCE_NAME` interrupts to occur.
*
* \param None
*
* \return None
*
* \sideeffect None
*
*******************************************************************************/


/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_IRQ_Disable
****************************************************************************//* 
*
* \brief Disables end of conversion interrupts. 
*
* \param None
* 
* \return None
* 
* \sideeffect None
*
*******************************************************************************/


/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetEosMask
****************************************************************************//**
*
* \brief Sets of clears the End of Scan (EOS) interrupt mask. 
*
* \param mask 1 to set the mask, 0 to clear the mask.
*
* \return None
* 
* \sideeffect All other bits in the INTR register are cleared by this function.
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetEosMask(uint32 mask)
{
    `$INSTANCE_NAME`_SAR_INTR_MASK_REG = mask & `$INSTANCE_NAME`_EOS_MASK;
    
    return;
}

/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_SetChanMask
****************************************************************************//*
*
* \brief Sets enable/disable mask for all channels in current configuration.
*
*
* \param enableMask
*  Channel enable/disable mask.
*
* \sideeffect
*  None.
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetChanMask(uint32 enableMask)
{
    uint32 chanCount = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels;
    enableMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    `$INSTANCE_NAME`_SAR_CHAN_EN_REG = enableMask;
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_IsEndConversion
****************************************************************************//**
*
* \brief Immediately returns the status of the conversion or does not return 
* (blocking) until the conversion completes, depending on the retMode parameter.
*
* \param retMode Check conversion return mode. See the following table for 
* options.
* | Options                              | Description                             |
* | :-------------------------------     | :-------------------------------------- |
* | `$INSTANCE_NAME`_RETURN_STATUS       | Immediately returns the conversion status for sequential channels. If the value returned is zero, the conversion is not complete, and this function should be retried until a nonzero result is returned. |
* | `$INSTANCE_NAME`_WAIT_FOR_RESULT     | Does not return a result until the `$INSTANCE_NAME` conversion of all sequential channels is complete. |
* 
* \return uint8: If a nonzero value is returned, the last conversion is complete. 
* If the returned value is zero, the `$INSTANCE_NAME` is still calculating the last result.
*
* \sideeffect This function reads the end of conversion status, and clears it afterward.
* 
*******************************************************************************/
uint32 `$INSTANCE_NAME`_IsEndConversion(uint32 retMode)
{
    uint32 endOfConversion = 0u;
    uint32 wdt = 0x3FFFFFFuL; /* Watchdog timer for blocking while loop */
    if((`$INSTANCE_NAME`_RETURN_STATUS == retMode) || (`$INSTANCE_NAME`_WAIT_FOR_RESULT == retMode))
    {
        do
        {
            endOfConversion = `$INSTANCE_NAME`_SAR_INTR_REG & `$INSTANCE_NAME`_EOS_MASK;
            wdt--;
        }while(((0u == endOfConversion) 
            && (((uint32) retMode & `$INSTANCE_NAME`_WAIT_FOR_RESULT) != 0u))
            && (0uL != wdt));

        if(0u != endOfConversion)
        {
            /* Clear EOS bit */
            `$INSTANCE_NAME`_SAR_INTR_REG = `$INSTANCE_NAME`_EOS_MASK;
        }
    }
    
    return endOfConversion;
}
 
/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_IsChannelSigned(uint32 chan)
****************************************************************************//*
*
* Determines if the provided channel is in signed format. 
*
* \param chan The `$INSTANCE_NAME` channel to check. 
*
* \return None
* 
* \sideeffect None
*
*
*******************************************************************************/
static int32 `$INSTANCE_NAME`_IsChannelSigned(uint32 chan)
{
    int32 isSigned = 0;
    uint32 chanConfig;
    
    chanConfig = CY_GET_REG32((reg32 *)(`$INSTANCE_NAME`_SAR_CHAN_CONFIG_IND + (uint32)(chan << 2u)));
    /* If differential mode */
    if(0u != (chanConfig & `$INSTANCE_NAME`_CHANNEL_CONFIG_DIFF_ALL_MSK))
    {
        /*If signed differential */
        if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
            & `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_DIFFERENTIAL_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    else
    {
        if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl
            & `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) != 0u)
        {
            isSigned = 1;
        }
    }
    return isSigned;
}
/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_GetResult16
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register
*
* \param chan The `$INSTANCE_NAME` channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 16-bit integer.
* 
* \sideeffect None
* 
*******************************************************************************/
int16 `$INSTANCE_NAME`_GetResult16(uint32 chan)
{
    uint32 adcResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels);

    if(`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels > chan)
    {   
        adcResult = CY_GET_REG32((reg32 *)(`$INSTANCE_NAME`_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            `$INSTANCE_NAME`_RESULT_MASK; 
    }
    else
    {
		adcResult = 0u;
    }
    
    return (int16) adcResult;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_GetResult32
****************************************************************************//**
*
* \brief Gets the data available in the channel result data register. 
*
* \param chan The `$INSTANCE_NAME` channel to read the result from. The first 
* channel is 0 and the injection channel if enabled is the number of valid 
* channels.
*
* \return Returns converted data as a signed 32-bit integer.
* 
* \sideeffect None
*
*******************************************************************************/
int32 `$INSTANCE_NAME`_GetResult32(uint32 chan)
{
    uint32 adcResult;
    int16 adcResult16;
    int32 finalResult;
    
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels);

    if(`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels > chan)
    {
        adcResult = CY_GET_REG32((reg32 *)(`$INSTANCE_NAME`_SAR_CHAN_RESULT_IND + (uint32)(chan << 2u))) &
            `$INSTANCE_NAME`_RESULT_MASK;
    }
    else
    {
        adcResult = 0u;
    }
    /* Sign extend if channel is signed format */
    if(`$INSTANCE_NAME`_IsChannelSigned(chan) == 1)
    {
        adcResult16 = (int16) adcResult;
        finalResult = (int32) adcResult16;
    }
    else
    {
        finalResult = (int32) adcResult;
    }
    return finalResult;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetLowLimit
****************************************************************************//**
*
* \brief Sets the low limit parameter for a limit condition.
*
* \param lowLimit The low limit for a limit condition.
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetLowLimit(uint32 lowLimit)
{   
    `$INSTANCE_NAME`_SAR_RANGE_THRES_REG &= ~(uint32)(`$INSTANCE_NAME`_SAR_RANGE_THRES_RANGE_LOW_MSK);
    `$INSTANCE_NAME`_SAR_RANGE_THRES_REG |= lowLimit & `$INSTANCE_NAME`_SAR_RANGE_THRES_RANGE_LOW_MSK;
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetHighLimit
****************************************************************************//**
*
* \brief Sets the high limit parameter for a limit condition.
*
* \param highLimit The high limit for a limit condition.
*
* \return None
* 
* \sideeffect None
* 
*******************************************************************************/
void `$INSTANCE_NAME`_SetHighLimit(uint32 highLimit)
{   
    `$INSTANCE_NAME`_SAR_RANGE_THRES_REG &= ~(uint32)(`$INSTANCE_NAME`_SAR_RANGE_THRES_RANGE_HIGH_MSK);
    `$INSTANCE_NAME`_SAR_RANGE_THRES_REG |= (uint32)(highLimit << `$INSTANCE_NAME`_SAR_RANGE_THRES_RANGE_HIGH_SHFT);
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetLimitMask
****************************************************************************//**
*
* \brief Sets the channel limit condition mask.
*
* \param limitMask Sets which channels that may cause a limit condition interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 6  channels were enabled, setting a mask of 0x0103 would only enable 
* the last two channels (0 and 1).
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetLimitMask(uint32 limitMask)
{   
    uint32 chanCount = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels;
    limitMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    `$INSTANCE_NAME`_SAR_RANGE_INTR_MASK_REG = limitMask;
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetSatMask
****************************************************************************//**
*
* \brief Sets the channel saturation event mask.
*
* \param satMask Sets which channels that may cause a saturation event interrupt. 
* Setting bits for channels that do not exist will have no effect. For example, 
* if only 8 channels were enabled, setting a mask of 0x01C0 would only enable two 
* channels (6 and 7).
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetSatMask(uint32 satMask)
{   
    uint32 chanCount = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels;
    satMask &= (uint32)((uint32)(1ul << chanCount) - 1ul);
    `$INSTANCE_NAME`_SAR_SATURATE_INTR_MASK_REG = satMask;    
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetOffset
****************************************************************************//**
*
* \brief Sets the ADC offset that is used by the functions `$INSTANCE_NAME`_CountsTo_uVolts, 
* `$INSTANCE_NAME`_CountsTo_mVolts, and `$INSTANCE_NAME`_CountsTo_Volts.
* 
* Offset is applied to counts before unit scaling and gain.  All CountsTo_[mV, uV, V]olts()
* functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's offset based on known V_offset_mV, use:
*     `$INSTANCE_NAME`_SetOffset(0uL, -1 * V_offset_mV * (1uL << (Resolution - 1)) / V_ref_mV);
*
* \param chan `$INSTANCE_NAME` channel number. 
* 
* \param offset This value is a measured value when the inputs are shorted or 
* connected to the same input voltage.
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetOffset(uint32 chan, int16 offset)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels);

    `$INSTANCE_NAME`_offset[`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan] = offset;
    return;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_SetGain
****************************************************************************//**
*
* \brief Sets the `$INSTANCE_NAME` gain in counts per 10 volt for the voltage 
* conversion functions. This value is set by default by the reference and 
* input range settings. Gain is applied after offset and unit scaling.  All 
* CountsTo_[mV, uV, V]olts() functions use the following equation:
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* See CountsTo_Volts() for more about this formula.
* 
* To set channel 0's gain based on known V_ref_mV, use:
*     `$INSTANCE_NAME`_SetGain(0uL, 10000 * (1uL << (Resolution - 1)) / V_ref_mV);
*  
* \param chan `$INSTANCE_NAME` channel number.
* 
* \param adcGain `$INSTANCE_NAME` gain in counts per 10 volt.
*
* \return None
* 
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_SetGain(uint32 chan, int32 adcGain)
{   
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels);

    `$INSTANCE_NAME`_countsPer10Volt[`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan]
	= adcGain;
    return;
}
/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_RawCounts2Counts
****************************************************************************//**
*
* \brief Converts the output of the SAR to an idealized count value.
*
* Divides by averaging amount, if needed, and subtracts offset.
*
* \param chan `$INSTANCE_NAME` channel number.   
*
* \param adcCounts Result from the `$INSTANCE_NAME` conversion.
*
* \return Averaged and offset counts.
* 
* \sideeffect None
*******************************************************************************/
int16 `$INSTANCE_NAME`_RawCounts2Counts(uint32 chan, int16 adcCounts)
{
    uint32 temp;
	uint32 averageAdcSamplesDiv;
	uint32 rawChannel;
	rawChannel = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan;
	
    /* Halt CPU in debug mode if channel is out of valid range */
    CYASSERT(chan < `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].numChannels);

    /* Divide the adcCount when accumulate averaging mode selected */
    /* If Average mode != fixed */
	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK) 
		!= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_SHIFT_MSK)
	{
        /* If Channel uses averaging */
        if((`$INSTANCE_NAME`_channelsConfig[rawChannel] & `$INSTANCE_NAME`_SAR_CHAN_CONFIG_AVG_EN_MSK) != 0u)
        {
            /* Divide by 2^(AVG_CNT + 1) */
			averageAdcSamplesDiv = ((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
				& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_CNT_MSK) 
				>> `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_CNT_SHFT);
            averageAdcSamplesDiv = (1uL << (averageAdcSamplesDiv + 1uL));
                        /* When it's "Sequential, Sum", divider limit is 16 */
            /* If Mode is ACCUNDUMP */
            if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
    			& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_MODE_MSK) 
    			!= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_AVG_MODE_MSK)
    		{
                if (averageAdcSamplesDiv > 16uL)
                {
                    averageAdcSamplesDiv = 16uL;
                }
            }
            /* If unsigned format, prevent sign extension */
            if(0 == `$INSTANCE_NAME`_IsChannelSigned(chan))
            {
				temp = ((uint16) adcCounts / averageAdcSamplesDiv);
                adcCounts = (int16) temp;
            }
            else
            {
                adcCounts /= (int16) averageAdcSamplesDiv;
            }
        }
    }
    /* Subtract ADC offset */
    adcCounts -= `$INSTANCE_NAME`_offset[rawChannel];
    return adcCounts;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_CountsTo_Volts
****************************************************************************//**
*
* \brief Converts the ADC output to Volts as a float32. For example, if the ADC 
* measured 0.534 volts, the return value would be 0.534.
* The calculation of voltage depends on the contents of `$INSTANCE_NAME`_offset[],
* `$INSTANCE_NAME`_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = `$INSTANCE_NAME`_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = `$INSTANCE_NAME`_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan `$INSTANCE_NAME` channel number.   
*
* \param adcCounts Result from the `$INSTANCE_NAME` conversion.
*
* \return Result in Volts.
* 
* \sideeffect None
*
*******************************************************************************/
float32 `$INSTANCE_NAME`_CountsTo_Volts(uint32 chan, int16 adcCounts)
{   
    float32 result_Volts = 0.0f;
	uint32 rawChannel;
	rawChannel = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan;
	
	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = `$INSTANCE_NAME`_RawCounts2Counts(chan, adcCounts);

        result_Volts = ((float32)adcCounts * `$INSTANCE_NAME`_10V_COUNTS) 
			/ (float32)`$INSTANCE_NAME`_countsPer10Volt[rawChannel];
	}
	return result_Volts;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_CountsTo_mVolts
****************************************************************************//**
*
* \brief Converts the ADC output to millivolts as an int16. For example, if the ADC 
* measured 0.534 volts, the return value would be 534.
* The calculation of voltage depends on the contents of `$INSTANCE_NAME`_offset[],
* `$INSTANCE_NAME`_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = `$INSTANCE_NAME`_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = `$INSTANCE_NAME`_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan `$INSTANCE_NAME` channel number. 
*
* \param adcCounts Result from the `$INSTANCE_NAME` conversion.
* 
* \return Result in mV.
* 
* \sideeffect None.
*
*******************************************************************************/
int16 `$INSTANCE_NAME`_CountsTo_mVolts(uint32 chan, int16 adcCounts)
{   
    int16 result_mVolts = 0;
	uint32 rawChannel;
    
	rawChannel = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan;
	
	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = `$INSTANCE_NAME`_RawCounts2Counts(chan, adcCounts);

	    result_mVolts = (int16)((((int32)adcCounts * `$INSTANCE_NAME`_10MV_COUNTS) + ( (adcCounts > 0) ? 
	             (`$INSTANCE_NAME`_countsPer10Volt[rawChannel] / 2) 
				: (-(`$INSTANCE_NAME`_countsPer10Volt[rawChannel] / 2)) )) 
	             / `$INSTANCE_NAME`_countsPer10Volt[rawChannel]);
	}
    return result_mVolts;
}

/*******************************************************************************
* Function Name: `$INSTANCE_NAME`_CountsTo_uVolts
****************************************************************************//**
*
* \brief Converts the ADC output to microvolts as an int32. For example, if the ADC 
* measured 0.534 volts, the return value would be 534000.
* The calculation of voltage depends on the contents of `$INSTANCE_NAME`_offset[],
* `$INSTANCE_NAME`_countsPer10Volt[], and other parameters.  The equation used is:
* 
*     V = (Counts/AvgDivider - Offset)*TEN_VOLT/Gain
* -Counts = Raw Counts from SAR register
* -AvgDivider = divider based on averaging mode
*     -Sequential, Sum: AvgDivider = number averaged
*         Note: The divider should be a maximum of 16. If using more averages, 
*         pre-scale Counts by (number averaged / 16)
*     -Interleaved, Sum: AvgDivider = number averaged
*     -Sequential, Fixed: AvgDivider = 1
* -Offset = `$INSTANCE_NAME`_offset[]
* -TEN_VOLT = 10V constant and unit scalar.
* -Gain = `$INSTANCE_NAME`_countsPer10Volt[]
* 
* When the Vref is based on Vdda, the value used for Vdda is set for the project
* in the System tab of the DWR.
*
* \param chan `$INSTANCE_NAME` channel number.   
*
* \param adcCounts Result from the `$INSTANCE_NAME` conversion.
*
* \return Result in microvolts.
* 
* \sideeffect None
*
*******************************************************************************/
int32 `$INSTANCE_NAME`_CountsTo_uVolts(uint32 chan, int16 adcCounts)
{   
    int64 result_uVolts = 0;
	uint32 rawChannel;
	rawChannel = `$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].channelBase + chan;

	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].sampleCtrl 
		& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK) 
		!= `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_LEFT_ALIGN_MSK)
	{
        adcCounts = `$INSTANCE_NAME`_RawCounts2Counts(chan, adcCounts);

        result_uVolts = ((int64)adcCounts * `$INSTANCE_NAME`_10UV_COUNTS) 
			/ `$INSTANCE_NAME`_countsPer10Volt[rawChannel];
	}
	return ( (int32)result_uVolts );
}

#if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)
    
    /* ****************************************************************************
    * Function Name: `$INSTANCE_NAME`_TrimFilterVos
    ****************************************************************************//*
    *
    * \brief Runs an algorithm to reduce voltage offset using the UAB's opamp trim.
    *
    * \param None
    * 
    * \return None
    *
    * \sideeffect None
    *
    *******************************************************************************/
    void `$INSTANCE_NAME`_TrimFilterVos(void)
    {
        uint32 opampTrim = 0uL;
        uint32 agndTrim = 0uL;
        uint32 compStatus = 0uL;
        
        `$INSTANCE_NAME`_SetupComparatorTrim();
        
        /* Sweep from center to crossing */
        compStatus = `$INSTANCE_NAME`_SetOpampAndAgndTrim(`$INSTANCE_NAME`_OPAMP_TRIM_POS_BASE, `$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
        if (0uL == compStatus)
        {
            opampTrim = `$INSTANCE_NAME`_RaiseOpampTrimToCrossing(`$INSTANCE_NAME`_OPAMP_TRIM_POS_BASE);
            agndTrim = `$INSTANCE_NAME`_RaiseAgndTrimToCrossing(`$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            if ((agndTrim == (`$INSTANCE_NAME`_AGND_TRIM_POS_LIMIT - 1uL))
                && (opampTrim != (`$INSTANCE_NAME`_OPAMP_TRIM_POS_LIMIT - 1uL)))
            {
                opampTrim = `$INSTANCE_NAME`_IncOpampTrim(opampTrim);
                (void) `$INSTANCE_NAME`_SetOpampAndAgndTrim(opampTrim, `$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
                (void) `$INSTANCE_NAME`_LowerAgndTrimToCrossing(`$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            }
        }
        else
        {
            opampTrim = `$INSTANCE_NAME`_LowerOpampTrimToCrossing(`$INSTANCE_NAME`_OPAMP_TRIM_POS_BASE);
            agndTrim = `$INSTANCE_NAME`_LowerAgndTrimToCrossing(`$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            if ((agndTrim == (`$INSTANCE_NAME`_AGND_TRIM_NEG_LIMIT - 1uL))
                && (opampTrim != (`$INSTANCE_NAME`_OPAMP_TRIM_NEG_LIMIT - 1uL)))
            {
                opampTrim = `$INSTANCE_NAME`_DecOpampTrim(opampTrim);
                (void) `$INSTANCE_NAME`_SetOpampAndAgndTrim(opampTrim, `$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
                (void) `$INSTANCE_NAME`_RaiseAgndTrimToCrossing(`$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            }
        }
        
        `$INSTANCE_NAME`_UndoComparatorTrimSetup();
    }
    
    
    static void `$INSTANCE_NAME`_SetupComparatorTrim(void)
    {
        /* Set firmware modbit. */
        `$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        `$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_REG |= (0x1uL << CyUAB_SIGN_VAL_SHIFT);
        
        /* Open filter output switch to isolate filter during trim. */
        `$INSTANCE_NAME`_UABH_B_SW_CF_BOT_REG &= ~(uint32)(`$INSTANCE_NAME`_UABH_B_SW_PO_MASK);
        
        /* Power on the UAB half B reference buffer. */
        `$INSTANCE_NAME`_UABH_B_OA_CTRL_REG |= (uint32)`$INSTANCE_NAME`_UABH_B_REF_PWR_MASK;
        
        /* Connect the UAB half B reference buffer to the comparator. */
        `$INSTANCE_NAME`_UABH_B_SW_STATIC_REG |= (uint32)`$INSTANCE_NAME`_UABH_B_SW_RT_MASK;
                        
        /* Clock the UAB half B comparator with phi1. */
        `$INSTANCE_NAME`_UABH_B_SW_OTHER_REG &= ~(uint32)`$INSTANCE_NAME`_UABH_B_CMP_FF_MASK;
        `$INSTANCE_NAME`_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_CLK_PHI1 << `$INSTANCE_NAME`_UABH_B_CMP_FF_SHIFT);
        
        /* Power on the UAB half B comparator. */
        `$INSTANCE_NAME`_UABH_B_OA_CTRL_REG |= (uint32)`$INSTANCE_NAME`_UABH_B_CMP_PWR_MASK;
    }
    
    
    static void `$INSTANCE_NAME`_UndoComparatorTrimSetup(void)
    {
        /* Power off the UAB half B comparator. */
        `$INSTANCE_NAME`_UABH_B_OA_CTRL_REG &= ~(uint32)`$INSTANCE_NAME`_UABH_B_CMP_PWR_MASK;
        
        /* Remove clock from the UAB half B comparator. */
        `$INSTANCE_NAME`_UABH_B_SW_OTHER_REG &= ~(uint32)`$INSTANCE_NAME`_UABH_B_CMP_FF_MASK;
        `$INSTANCE_NAME`_UABH_B_SW_OTHER_REG |= (uint32)((uint32)CyUAB_SW_OPEN << `$INSTANCE_NAME`_UABH_B_CMP_FF_SHIFT);
        
        /* Disconnect the UAB half B reference buffer from the comparator. */
        `$INSTANCE_NAME`_UABH_B_SW_STATIC_REG &= ~(uint32)`$INSTANCE_NAME`_UABH_B_SW_RT_MASK;
                        
        /* Power off the UAB half B reference buffer. */
        `$INSTANCE_NAME`_UABH_B_OA_CTRL_REG &= ~(uint32)`$INSTANCE_NAME`_UABH_B_REF_PWR_MASK;
        
        /* Close filter output switch to connect filter to AROUTE. */
        `$INSTANCE_NAME`_UABH_B_SW_CF_BOT_REG &= ~(uint32)(`$INSTANCE_NAME`_UABH_B_SW_PO_MASK);
        `$INSTANCE_NAME`_UABH_B_SW_CF_BOT_REG |= (uint32)((uint32)CyUAB_CLK_PHI3 << `$INSTANCE_NAME`_UABH_B_SW_PO_SHIFT);
        
        /* Clear the modbit */
        `$INSTANCE_NAME`_UABH_A_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
        `$INSTANCE_NAME`_UABH_B_CAP_ABCF_VAL_REG &= ~(0x1uL << CyUAB_SIGN_VAL_SHIFT);
    }
    
    
    static uint32 `$INSTANCE_NAME`_RaiseOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != `$INSTANCE_NAME`_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = `$INSTANCE_NAME`_IncOpampTrim(opampTrim))
        {
            compStatus = `$INSTANCE_NAME`_SetOpampAndAgndTrim(opampTrim, `$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            if (0uL != compStatus)
            {
                (void) `$INSTANCE_NAME`_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 `$INSTANCE_NAME`_LowerOpampTrimToCrossing(uint32 startTrim)
    {
        uint32 opampTrim;
        uint32 lastOpampTrim;
        uint32 compStatus;

        lastOpampTrim = startTrim;
        for (opampTrim = startTrim;
            opampTrim != `$INSTANCE_NAME`_OPAMP_TRIM_NEG_LIMIT;
            opampTrim = `$INSTANCE_NAME`_DecOpampTrim(opampTrim))
        {
            compStatus = `$INSTANCE_NAME`_SetOpampAndAgndTrim(opampTrim, `$INSTANCE_NAME`_AGND_TRIM_POS_BASE);
            if (0uL == compStatus)
            {
                (void) `$INSTANCE_NAME`_SetOpampTrim(lastOpampTrim);
                break;
            }
            lastOpampTrim = opampTrim;
        }
        
        return lastOpampTrim;
    }


    static uint32 `$INSTANCE_NAME`_RaiseAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim;
        uint32 lastAgndTrim;
        uint32 compStatus;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != `$INSTANCE_NAME`_AGND_TRIM_NEG_LIMIT;
            agndTrim = `$INSTANCE_NAME`_IncAgndTrim(agndTrim))
        {
            compStatus = `$INSTANCE_NAME`_SetAgndTrim(agndTrim);
            if (0uL != compStatus)
            {
                (void) `$INSTANCE_NAME`_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 `$INSTANCE_NAME`_LowerAgndTrimToCrossing(uint32 startTrim)
    {
        uint32 agndTrim = startTrim;
        uint32 lastAgndTrim = agndTrim;
        uint32 compStatus = 1uL;

        lastAgndTrim = startTrim;
        for (agndTrim = startTrim;
            agndTrim != `$INSTANCE_NAME`_AGND_TRIM_NEG_LIMIT;
            agndTrim = `$INSTANCE_NAME`_DecAgndTrim(agndTrim))
        {
            compStatus = `$INSTANCE_NAME`_SetAgndTrim(agndTrim);
            if (0uL == compStatus)
            {
                (void) `$INSTANCE_NAME`_SetAgndTrim(lastAgndTrim); 
                break;
            }
            lastAgndTrim = agndTrim;
        }
        
        return lastAgndTrim;
    }
    
    
    static uint32 `$INSTANCE_NAME`_SetOpampAndAgndTrim(uint32 opampTrim, uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = `$INSTANCE_NAME`_UABH_A_OA_TRIM_OA_REG;
        trimRegVal &= ~(`$INSTANCE_NAME`_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        `$INSTANCE_NAME`_UABH_A_OA_TRIM_OA_REG = trimRegVal;
                
        trimRegVal = `$INSTANCE_NAME`_UABH_A_OA_TRIM_AGND_REG;
        trimRegVal &= ~(`$INSTANCE_NAME`_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        `$INSTANCE_NAME`_UABH_A_OA_TRIM_AGND_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = `$INSTANCE_NAME`_UABH_B_STAT_REG & `$INSTANCE_NAME`_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 `$INSTANCE_NAME`_SetOpampTrim(uint32 opampTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = `$INSTANCE_NAME`_UABH_A_OA_TRIM_OA_REG;
        trimRegVal &= ~(`$INSTANCE_NAME`_OPAMP_TRIM_MASK << CyUAB_OA_OFFSET_SHIFT);
        trimRegVal |= (opampTrim << CyUAB_OA_OFFSET_SHIFT);
        `$INSTANCE_NAME`_UABH_A_OA_TRIM_OA_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = `$INSTANCE_NAME`_UABH_B_STAT_REG & `$INSTANCE_NAME`_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    
    static uint32 `$INSTANCE_NAME`_SetAgndTrim(uint32 agndTrim)
    {
        uint32 compStatus = 0uL;
 
        uint32 trimRegVal = `$INSTANCE_NAME`_UABH_A_OA_TRIM_AGND_REG;
        trimRegVal &= ~(`$INSTANCE_NAME`_AGND_TRIM_MASK << CyUAB_AGND_OFFSET_SHIFT);
        trimRegVal |= (agndTrim << CyUAB_AGND_OFFSET_SHIFT);
        `$INSTANCE_NAME`_UABH_A_OA_TRIM_AGND_REG = trimRegVal;
        
        CyDelayUs(100u);
        
        compStatus = `$INSTANCE_NAME`_UABH_B_STAT_REG & `$INSTANCE_NAME`_UABH_B_COMP_MASK;
        
        return compStatus;
    }
    
    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 `$INSTANCE_NAME`_IncOpampTrim(uint32 trim)
    {
        
        if (trim < (`$INSTANCE_NAME`_OPAMP_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((`$INSTANCE_NAME`_OPAMP_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = `$INSTANCE_NAME`_OPAMP_TRIM_NEG_LIMIT;
        }
        else if (trim <= (`$INSTANCE_NAME`_OPAMP_TRIM_NEG_BASE + 1uL))
        {
            trim = `$INSTANCE_NAME`_OPAMP_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips OPAMP_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 `$INSTANCE_NAME`_DecOpampTrim(uint32 trim)
    {
        
        if (`$INSTANCE_NAME`_OPAMP_TRIM_POS_BASE == trim)
        {
            trim = `$INSTANCE_NAME`_OPAMP_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < `$INSTANCE_NAME`_OPAMP_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < `$INSTANCE_NAME`_OPAMP_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = `$INSTANCE_NAME`_OPAMP_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }


    /* Skips AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 `$INSTANCE_NAME`_IncAgndTrim(uint32 trim)
    {
        
        if (trim < (`$INSTANCE_NAME`_AGND_TRIM_POS_LIMIT - 1uL))
        {
            trim = trim + 1uL;
        }
        else if ((`$INSTANCE_NAME`_AGND_TRIM_POS_LIMIT - 1uL) == trim)
        {
            trim = `$INSTANCE_NAME`_AGND_TRIM_NEG_LIMIT;
        }
        else if (trim <= (`$INSTANCE_NAME`_AGND_TRIM_NEG_BASE + 1uL))
        {
            trim = `$INSTANCE_NAME`_AGND_TRIM_POS_BASE;
        }
        else
        {
            trim = trim - 1uL;
        }
        
        return trim;
    }


    /* Skips `$INSTANCE_NAME`_AGND_TRIM_NEG_BASE because it is the same as POS_BASE. */
    static uint32 `$INSTANCE_NAME`_DecAgndTrim(uint32 trim)
    {
        
        if (trim == `$INSTANCE_NAME`_AGND_TRIM_POS_BASE)
        {
            trim = `$INSTANCE_NAME`_AGND_TRIM_NEG_BASE + 1uL;
        }
        else if (trim < `$INSTANCE_NAME`_AGND_TRIM_POS_LIMIT)
        {
            trim = trim - 1uL;
        }
        else if (trim < `$INSTANCE_NAME`_AGND_TRIM_NEG_LIMIT)
        {
            trim = trim + 1uL;
        }
        else
        {
            trim = `$INSTANCE_NAME`_AGND_TRIM_POS_LIMIT - 1uL;
        }
        
        return trim;
    }

    
    void `$INSTANCE_NAME`_filterInit(uint32 configNum)
    {
        /* Configure the common filter settings if any configuration filters */
        switch (configNum)
        {
            #if (0u != `$INSTANCE_NAME`_CFG0_FILTER_PRESENT)
            case 0u:
    		    `$INSTANCE_NAME`_UABH_A_Init(&`$INSTANCE_NAME`_CFG0_UABH_A_FILTER_config);
    		    `$INSTANCE_NAME`_UABH_B_Init(&`$INSTANCE_NAME`_CFG0_UABH_B_FILTER_config);
                #if (`$INSTANCE_NAME`_CFG0_TRANSFERTYPE != `$INSTANCE_NAME`_TRANSFERTYPE_HIGH_PASS)
                    `$INSTANCE_NAME`_UABH_B_SetRC(CyUAB_RC_RES_1_5kOHM, CyUAB_RC_CAP_4pF);
                #endif
            break;
            #endif
            #if (0u != `$INSTANCE_NAME`_CFG1_FILTER_PRESENT)
            case 1u:
    		    `$INSTANCE_NAME`_UABH_A_Init(&`$INSTANCE_NAME`_CFG1_UABH_A_FILTER_config);
    		    `$INSTANCE_NAME`_UABH_B_Init(&`$INSTANCE_NAME`_CFG1_UABH_B_FILTER_config);
                #if (`$INSTANCE_NAME`_CFG1_TRANSFERTYPE != `$INSTANCE_NAME`_TRANSFERTYPE_HIGH_PASS)
                    `$INSTANCE_NAME`_UABH_B_SetRC(CyUAB_RC_RES_1_5kOHM, CyUAB_RC_CAP_4pF);
                #endif                
            break;
            #endif
            #if (0u != `$INSTANCE_NAME`_CFG2_FILTER_PRESENT)
            case 2u:
    		    `$INSTANCE_NAME`_UABH_A_Init(&`$INSTANCE_NAME`_CFG2_UABH_A_FILTER_config);
    		    `$INSTANCE_NAME`_UABH_B_Init(&`$INSTANCE_NAME`_CFG2_UABH_B_FILTER_config);
                #if (`$INSTANCE_NAME`_CFG2_TRANSFERTYPE != `$INSTANCE_NAME`_TRANSFERTYPE_HIGH_PASS)
                    `$INSTANCE_NAME`_UABH_B_SetRC(CyUAB_RC_RES_1_5kOHM, CyUAB_RC_CAP_4pF);
                #endif                
            break;
            #endif
            #if (0u != `$INSTANCE_NAME`_CFG3_FILTER_PRESENT)
            case 3u:
    		    `$INSTANCE_NAME`_UABH_A_Init(&`$INSTANCE_NAME`_CFG3_UABH_A_FILTER_config);
    		    `$INSTANCE_NAME`_UABH_B_Init(&`$INSTANCE_NAME`_CFG3_UABH_B_FILTER_config);
                #if (`$INSTANCE_NAME`_CFG3_TRANSFERTYPE != `$INSTANCE_NAME`_TRANSFERTYPE_HIGH_PASS)
                    `$INSTANCE_NAME`_UABH_B_SetRC(CyUAB_RC_RES_1_5kOHM, CyUAB_RC_CAP_4pF);
                #endif                
            break;
            #endif
            default:
            break;
        }
        
        /* Connect the bulk to switch source for low Vdda (< 2V). */
        #if (CYDEV_VDDA_MV < `$INSTANCE_NAME`_BULK_VDDA_MV_THRESHOLD)
            `$INSTANCE_NAME`_UABH_A_SetBulk(CyUAB_BULK_SOURCE);
            `$INSTANCE_NAME`_UABH_B_SetBulk(CyUAB_BULK_SOURCE);
        #endif
        
        `$INSTANCE_NAME`_FILTERAGND2SAR_BUFFER_Init();
    }
#endif /* `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER != 0u */


/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_Init
****************************************************************************//*
*
* \brief Initialize the component according to parameters defined in the 
* customizer.
*
* \param None
* 
* \return None
*
* \sideeffect None
*
*******************************************************************************/
void `$INSTANCE_NAME`_Init(void)
{
	uint32 chNum = 0ul;
	uint32 configNum = 0u;
	int32 counts;
	
	if(0u == `$INSTANCE_NAME`_initVar)
	{
		/* Set offset and countsPer10Volt for all channels */
		for(chNum = 0ul; chNum < `$INSTANCE_NAME`_TOTAL_CHANNELS_NUM; chNum++)
		{      
			if((`$INSTANCE_NAME`_channelsConfig[chNum] & `$INSTANCE_NAME`_SAR_CHAN_CONFIG_RESOLUTION_MSK) != 0u)
        	{
				if((`$INSTANCE_NAME`_allConfigs[configNum].sampleCtrl 
					& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_SUB_RESOLUTION_MSK) 
					== `$INSTANCE_NAME`_SUB_RESOLUTION_10B)
				{
					counts = (int32) `$INSTANCE_NAME`_SAR_WRK_MAX_10BIT;
				}
				else
				{
					counts = (int32) `$INSTANCE_NAME`_SAR_WRK_MAX_8BIT;
				}
        	}
        	else
        	{
               counts = (int32)`$INSTANCE_NAME`_SAR_WRK_MAX_12BIT;
        	}
			
			/* Single Ended Channel */
			if((`$INSTANCE_NAME`_channelsConfig[chNum] & `$INSTANCE_NAME`_SAR_CHAN_CONFIG_DIFFERENTIAL_EN_MSK) == 0u)
        	{
				if(((`$INSTANCE_NAME`_allConfigs[configNum].sampleCtrl 
					& `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) 
					== `$INSTANCE_NAME`_SAR_SAMPLE_CTRL_SINGLE_ENDED_SIGNED_MSK) && 
					((`$INSTANCE_NAME`_allConfigs[configNum].ctrl & `$INSTANCE_NAME`_SAR_CTRL_NEG_SEL_MSK) 
					== `$INSTANCE_NAME`_NEG_VREF_SHIFTED))
				{
					/* Set offset to the minus half scale to convert results to unsigned format */
                	`$INSTANCE_NAME`_offset[chNum] = (int16)(counts / -2);		
            	}
				else
				{
                	`$INSTANCE_NAME`_offset[chNum] = 0;	
				}
				
			}
			else    /* Differential channel */
        	{
               	`$INSTANCE_NAME`_offset[chNum] = 0; 
			}
            
			/* Calculate gain in counts per 10 volts with rounding */
        	`$INSTANCE_NAME`_countsPer10Volt[chNum] = (int16)(((counts * `$INSTANCE_NAME`_10MV_COUNTS) \
                            + `$INSTANCE_NAME`_allConfigs[configNum].vrefMvValue) \
							/ (`$INSTANCE_NAME`_allConfigs[configNum].vrefMvValue * 2));
            
            /* Increment configuration number after rolling over to the next configuration*/
			if((`$INSTANCE_NAME`_allConfigs[configNum].channelBase
				+ (`$INSTANCE_NAME`_allConfigs[configNum].numChannels - 1uL)) == chNum)
			{
				configNum++;
			}
		} /* for(chNum = 0ul; chNum < `$INSTANCE_NAME`_TOTAL_CHANNELS_NUM; chNum++) */
        
        /* Start and set interrupt vector */
        CyIntSetPriority(`$INSTANCE_NAME`_INTC_NUMBER, `$INSTANCE_NAME`_INTC_PRIOR_NUMBER);
        (void)CyIntSetVector(`$INSTANCE_NAME`_INTC_NUMBER, &`$INSTANCE_NAME`_ISR);
        
        /* Initialize configuration zero if SelectConfig has not been called */
        if(0u == `$INSTANCE_NAME`_selected)
	    {
            `$INSTANCE_NAME`_selected = 1u;
            configNum = 0u;
            /* Change Vref selection if is was routed by Creator. Break. */
            #if (`$INSTANCE_NAME`_VREF_ROUTED)
                `$INSTANCE_NAME`_vrefAMux_DisconnectAll();
            #endif
            `$INSTANCE_NAME`_InitConfig(&`$INSTANCE_NAME`_allConfigs[configNum]);
            /* Change Vref selection if is was routed by Creator. Make. */
            #if (`$INSTANCE_NAME`_VREF_ROUTED)
                `$INSTANCE_NAME`_vrefAMux_Select((uint8)configNum);
            #endif
            `$INSTANCE_NAME`_SAR_CHAN_EN_REG = `$INSTANCE_NAME`_allConfigs[configNum].chanEn;
            #if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)	
                `$INSTANCE_NAME`_filterVinMux_Select((uint8)configNum);
                `$INSTANCE_NAME`_filterInit(configNum);
            #endif
        }           
	}
    return;
}


/* ****************************************************************************
* Function Name: `$INSTANCE_NAME`_Enable
****************************************************************************//*
*
* \brief Enables the component. 
*
* \param None
* 
* \return None
* 
* \sideeffect
*  None
*
*******************************************************************************/
void `$INSTANCE_NAME`_Enable(void) 
{

    #if(0u != `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER)	
    	if((`$INSTANCE_NAME`_allConfigs[`$INSTANCE_NAME`_currentConfig].miscConfig
    		& `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK)
    		== `$INSTANCE_NAME`_MISC_CONFIG_FILTER_PRESENT_MSK)
    	{
            `$INSTANCE_NAME`_FILTERAGND2SAR_BUFFER_Enable();
    		`$INSTANCE_NAME`_UABH_A_Enable();
    		`$INSTANCE_NAME`_UABH_B_Enable();
            `$INSTANCE_NAME`_UABH_B_Run(1u);
            `$INSTANCE_NAME`_UABH_A_Run(1u);
    	}
    #endif /* `$INSTANCE_NAME`_ANY_CONFIG_USES_FILTER != 0u */
        
    if (0u == (`$INSTANCE_NAME`_SAR_CTRL_REG & `$INSTANCE_NAME`_SAR_CTRL_ENABLED_MSK))
    {
        while (0u != (`$INSTANCE_NAME`_SAR_STATUS_REG & `$INSTANCE_NAME`_BUSY_MSK))
        {
            /* wait for SAR to go idle to avoid deadlock */
        }
        
        `$INSTANCE_NAME`_SAR_CTRL_REG |= `$INSTANCE_NAME`_SAR_CTRL_ENABLED_MSK;
        
        /* The block is ready to use 10 us after the enable signal is set high. */
        CyDelayUs(`$INSTANCE_NAME`_10US_DELAY);
    }
    return;
}


/* [] END OF FILE */
